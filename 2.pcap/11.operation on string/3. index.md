### **Indexing in Python**

**Indexing** in Python refers to accessing individual elements in a sequence (e.g., strings, lists, tuples) using their position, which is represented by an **index**. Indexes are integers starting from `0` for the first element. Python also supports **negative indexing**, where `-1` represents the last element.

---

### **Key Points About Indexing**
1. **Zero-based Indexing**: The first element has an index of `0`.
2. **Negative Indexing**: Index `-1` represents the last element, `-2` the second last, and so on.
3. **Accessing Nested Elements**: You can use multiple levels of indexing for nested data structures (e.g., lists of lists).
4. **Immutable vs Mutable**:
   - Strings and tuples are immutable, meaning their elements can't be changed via indexing.
   - Lists are mutable, so elements can be reassigned using indexing.

---

### **Indexing Syntax**
```python
sequence[index]
```

---

### **Examples**

#### Example 1: Indexing a String
```python
text = "Python"
# Accessing characters
print(text[0])  # Output: 'P' (first character)
print(text[2])  # Output: 't' (third character)

# Using negative indexing
print(text[-1])  # Output: 'n' (last character)
print(text[-3])  # Output: 'h' (third from last)
```

#### Example 2: Indexing a List
```python
numbers = [10, 20, 30, 40, 50]
# Accessing elements
print(numbers[1])   # Output: 20 (second element)
print(numbers[-2])  # Output: 40 (second last element)

# Modifying an element
numbers[2] = 100
print(numbers)  # Output: [10, 20, 100, 40, 50]
```

#### Example 3: Indexing a Tuple
```python
data = (5, 10, 15, 20)
print(data[0])   # Output: 5
print(data[-1])  # Output: 20

# Tuples are immutable, so this will raise an error
# data[1] = 50  # TypeError: 'tuple' object does not support item assignment
```

#### Example 4: Nested Indexing (Lists within Lists)
```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# Accessing sublists
print(nested_list[0])  # Output: [1, 2, 3]
print(nested_list[1][2])  # Output: 6 (third element of the second sublist)
```

#### Example 5: Using a Loop with Indexing
```python
fruits = ["apple", "banana", "cherry"]
for i in range(len(fruits)):
    print(f"Index {i}: {fruits[i]}")
# Output:
# Index 0: apple
# Index 1: banana
# Index 2: cherry
```

---

### **Applications of Indexing**

1. **String Manipulation**:
   Extract specific characters or substrings using indexes.
   ```python
   text = "Hello, World!"
   print(text[:5])  # Output: 'Hello' (slice using indexes)
   ```

2. **Accessing Data in Nested Structures**:
   Handle complex data structures like matrices or JSON-like data.
   ```python
   matrix = [[1, 2], [3, 4], [5, 6]]
   print(matrix[2][1])  # Output: 6
   ```

3. **Modifying Elements**:
   Update or delete elements in mutable sequences like lists.
   ```python
   numbers = [10, 20, 30]
   numbers[1] = 25
   print(numbers)  # Output: [10, 25, 30]
   ```

4. **Iterating with Index**:
   Combine loops with indexing to perform operations on specific elements.
   ```python
   words = ["cat", "dog", "bat"]
   for index, word in enumerate(words):
       print(f"Word at index {index}: {word}")
   ```

---

### **Errors in Indexing**
1. **IndexError**: Occurs when accessing an index out of the range.
   ```python
   numbers = [1, 2, 3]
   print(numbers[5])  # IndexError: list index out of range
   ```

2. **TypeError**: Occurs when the index is not an integer.
   ```python
   text = "hello"
   print(text[1.5])  # TypeError: string indices must be integers
   ```

---

### **Summary**
- **Indexing** is fundamental for accessing and manipulating individual elements in sequences.
- Python supports **positive and negative indexing**.
- Use **nested indexing** for multidimensional data structures.
- Handle errors gracefully to avoid common pitfalls like `IndexError`.